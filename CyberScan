import threading
import queue
import socket
import datetime
from tqdm import tqdm

# Entrada do usuÃ¡rio
alvo = input("Digite o IP ou domÃ­nio para escanear: ")

try:
    ip = socket.gethostbyname(alvo)
except socket.gaierror:
    print("[âœ–] NÃ£o foi possÃ­vel resolver o domÃ­nio.")
    exit()

# CabeÃ§alho bonito
print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
print("â•‘         ğŸš¨ CyberScan v3.5            â•‘")
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print(f"Alvo: {alvo} ({ip})")
print("Portas escaneadas: 1 atÃ© 1024")
inicio = datetime.datetime.now()
print("InÃ­cio:", inicio)
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

# ConfiguraÃ§Ãµes
portas_comuns = list(range(1, 1025))
servicos = {
    21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
    80: "HTTP", 110: "POP3", 139: "NetBIOS", 143: "IMAP", 443: "HTTPS",
    445: "SMB", 3306: "MySQL", 3389: "RDP", 8080: "HTTP-alt"
}
alertas = {
    21: "âš ï¸ FTP pode permitir ataques se nÃ£o tiver senha forte.",
    22: "âš ï¸ SSH pode sofrer ataques de forÃ§a bruta.",
    23: "âš ï¸ Telnet envia tudo sem criptografia.",
    80: "âš ï¸ HTTP nÃ£o Ã© criptografado.",
    445: "âš ï¸ Porta vulnerÃ¡vel a exploits como WannaCry.",
    3306: "âš ï¸ Banco de dados exposto!",
    3389: "âš ï¸ RDP pode permitir acesso remoto indevido."
}

# Lock para sincronizar acesso a variÃ¡veis compartilhadas
lock = threading.Lock()
abertas = 0
fechadas = 0

# Fila de portas
q = queue.Queue()

# Worker function
def worker(target_ip, services_dict, alerts_dict):
    global abertas, fechadas, pbar
    while True:
        porta = q.get()
        if porta is None:
            break
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.5)
        resultado = sock.connect_ex((target_ip, porta))
        servico = services_dict.get(porta, "Desconhecido")
        if resultado == 0:
            with lock:
                abertas += 1
            print(f"ğŸŸ¢ Porta {porta} ({servico}) ABERTA")
            # Banner grabbing
            try:
                sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
                banner = sock.recv(1024).decode().strip()
                if banner:
                    print(f"    ğŸ“¡ Banner: {banner.splitlines()[0]}")
            except:
                pass
            # Alerta de risco
            risco = alerts_dict.get(porta)
            if risco:
                print(f"    {risco}")
        else:
            with lock:
                fechadas += 1
        sock.close()
        q.task_done()
        if pbar:
            with lock:
                pbar.update(1)

# Inicializa a barra de progresso
pbar = tqdm(total=len(portas_comuns), desc="ğŸ” Escaneando portas", unit="porta")

# Enfileira as portas
for porta in portas_comuns:
    q.put(porta)

# Cria e inicia as threads
threads = []
num_threads = 50
for _ in range(num_threads):
    t = threading.Thread(target=worker, args=(ip, servicos, alertas))
    t.start()
    threads.append(t)

# Espera as threads finalizarem
q.join()
for _ in range(num_threads):
    q.put(None)
for t in threads:
    t.join()

# Fecha a barra de progresso
if pbar:
    pbar.close()

# Finaliza
fim = datetime.datetime.now()
duracao = fim - inicio

# RodapÃ©
print("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print(f"ğŸ” Escaneamento concluÃ­do em {duracao}")
print(f"ğŸŸ¢ Portas abertas: {abertas}")
print(f"ğŸ”´ Portas fechadas: {fechadas}")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
